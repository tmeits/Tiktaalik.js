(* ------|---------|---------|---------|---------|---------|---------|------- *)
(*       BBBB      EEEEE     L         The                                    *)
(*       B   B     E         L           BIOLOGICAL                           *)
(*       BBBB      EEE       L           ENGINEERING                          *)
(*       B    B    E         L           LABORATORY                           *)
(*       BBBBB     EEEEEE    LLLLLL        @ Saginaw Valley State University  *)
(* ------|---------|---------|---------|---------|---------|---------|------- *)
(* Copyright 2008-2010, Alan D. Freed                                         *)
(*                                                                            *)
(* This file is part of the BEL suite of .NET/mono libraries.                 *)
(*                                                                            *)
(* BEL is a free software: you can redistribute it and/or modify it under the *)
(* terms of the GNU Lesser General Public License as published by the Free    *)
(* Software Foundation, either version 3 of the License, or (at your option)  *)
(* any later version.                                                         *)
(*                                                                            *)
(* BEL is distributed in the hope that it will be useful, but WITHOUT ANY     *)
(* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  *)
(* FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for   *)
(* more details.                                                              *)
(*                                                                            *)
(* You should have received a copy of the GNU Lesser General Public License   *)
(* along with BEL.  If not, see <http://www.gnu.org/licenses/>.               *)
(* ------|---------|---------|---------|---------|---------|---------|------- *)
(* This module creates a floating-point (real) number type for the framework. *)
(* ------|---------|---------|---------|---------|---------|---------|------- *)
(* Type                                                                       *)
(*    NumberType             - internal data type used for Bel.MF.Numbers.Number *)
(* Object      : Number      - base type used for numeric computations        *)
(*    Methods  : Initialize; - implements Bel.Object.Initialize               *)
(*             : Nullify     - implements Bel.Object.Nullify                  *)
(*             : Clone       - implements Bel.Object.Clone                    *)
(*             : Load        - implements Bel.Object.Load                     *)
(*             : Store       - implements Bel.Object.Store                    *)
(*             : Negative    - implements Bel.Field.Negative                  *)
(*             : Add         - implements Bel.Field.Add                       *)
(*             : Subtract    - implements Bel.Field.Subtract                  *)
(*             : Multiply    - implements Bel.Field.Multiply                  *)
(*             : Divide      - implements Bel.Field.Divide                    *)
(*             : Parse       - converts a string into a Bel.MF.Numbers.Number *)
(*             : Typeset     - converts a Bel.MF.Numbers.Number into a string *)
(*             : ToString    - convert number to string at specified accuracy *)
(*             : Get         - returns the NumberType contained within        *)
(*             : Set         - assigns a NumberType to the internal data      *)
(*             : IsFinite    - boolean test to see if real is finite valued   *)
(*             : IsInfinite  - boolean test to see if real is +/- infinity    *)
(*             : IsPositiveInfinity - boolean test to see if real = infinity  *)
(*             : IsNegativeInfinity - boolean test to see if real = -infinity *)
(*             : IsNaN       - boolean test to see if real is not-a-number    *)
(*             : Equals             - boolean test for equality               *)
(*             : NotEqual           - boolean test for inequality             *)
(*             : LessThan           - boolean test for less than              *)
(*             : LessThanOrEqual    - boolean test for less than or equal to  *)
(*             : GreaterThan        - boolean test for greater than           *)
(*             : GreaterThanOrEqual - boolean test for greater than or equal  *)
(*             : Magnitude   - returns the absolute value of the number       *)
(*             : Power       - raises 1st number to power of 2nd number       *)
(* Constants   : Epsilon     - machine epsilon (not the Epsilon of .NET)      *)
(*                           - smallest number such that 1 + Epsilon > 1      *)
(*             : MaximumPositiveNumber - largest real w/full digit precision  *)
(*             : MinimumPositiveNumber - smallest real w/full digit precision *)
(*             : NaN                   - not-a-number, e.g., 0/0 returns NaN  *)
(*             : NegativeInfinity      - negative infinity: handles underflow *)
(*             : PositiveInfinity      - positive infinity: handles overflow  *)
(* Operators   : :=                         - assignment                      *)
(*             : -                          - uniary  operator                *)
(*             : = | # | < | <= | > | >=    - logical operators               *)
(*             : + | - | * | /              - binary arithmetic operators     *)
(*             : **                         - exponentiation operator         *)
(* ------|---------|---------|---------|---------|---------|---------|------- *)

module {public} Bel.MF.Numbers;

   import
      System.IO.BinaryReader as BinaryReader,
      System.IO.BinaryWriter as BinaryWriter,
      System.Convert as Convert,
      System.Math    as Math,
      System.Byte    as Card8,   (* core type of  cardinal{8}  *)
      System.UInt16  as Card16,  (* core type of  cardinal{16} *)
      System.UInt32  as Card32,  (* core type of  cardinal{32} *)
      System.UInt64  as Card64,  (* core type of  cardinal{64} *)
      System.Int16   as Int16,   (* core type of  integer{16}  *)
      System.Int32   as Int32,   (* core type of  integer{32}  *)
      System.Int64   as Int64,   (* core type of  integer{64}  *)
      System.SByte   as Int8,    (* core type of  integer{8}   *)
      System.Single  as Real32,  (* core type of  real{32}     *)
      System.Double  as Real64,  (* core type of  real{64}     *)
      Bel.IO.Log as L,
      Bel.Object as Object,
      Bel.Field  as Field;

   var {private}
      zero, one, two : Real64;

   var {public, immutable}
      Epsilon,
      MaximumPositiveNumber, MinimumPositiveNumber,
      NaN, NegativeInfinity, PositiveInfinity : Number;

   type {public}
      NumberType = Real64;
      (* internal type used in this implementation of Bel.MF.Numbers.Number *)

   type {private}
      CharArray = array * of char;

   type {public, value} Number = object implements Field

      var {private}
         x : NumberType;

      procedure {public} Initialize
         implements Object.Initialize;
      begin
         x := zero
      end Initialize;

      procedure {public} Nullify
         implements Object.Nullify;
      begin
         Initialize
      end Nullify;

      procedure {public} Clone () : object{Object}
         implements Object.Clone;
      var
         n : Number;
         o : object{Object};
      begin
         n.x := zero;
         o := Object(n);
         return o
      end Clone;

      procedure {public} Load (br : BinaryReader)
         implements Object.Load;
      begin
         x := br.ReadDouble()
      end Load;

      procedure {public} Store (bw : BinaryWriter)
         implements Object.Store;
      begin
         bw.Write(x);
         bw.Flush
      end Store;

      (* all arithmetic operators return 'NaN' whenever one or both *)
      (* arguments is a NaN, i.e., such operations are undefined    *)

      procedure {public} Negative () : object{Field}
         implements Field.Negative;
      var
         g : object{Field};
         y : Number;
      begin
        if IsFinite() then
           y.x := zero - x
        elsif IsNaN() then
           y.x := NaN.x
        elsif IsPositiveInfinity() then
           y.x := NegativeInfinity.x
        else
           y.x := PositiveInfinity.x
        end;
        g := Field(y);
        return g
      end Negative;

      (* infinities for additions and subtractions obey:            *)
      (*    x +/- infinity      -> +/-infinity                      *)
      (*    infinity + infinity -> infinity                         *)
      (*    infinity - infinity -> NaN                              *)

      procedure {public} Add (f : object{Field}) : object{Field}
         implements Field.Add;
      var
         g : object{Field};
         r, y : Number;
      begin
         if f is Number then
            r := Number(f);
            if IsFinite() & r.IsFinite() then
               y.x := x + r.x
            elsif IsNaN() or r.IsNaN() then
               y.x := NaN.x
            elsif IsPositiveInfinity() then
               if r.IsNegativeInfinity() then
                  y.x := NaN.x
               else
                  y.x := PositiveInfinity.x
               end
            elsif IsNegativeInfinity() then
               if r.IsPositiveInfinity() then
                  y.x := NaN.x
               else
                  y.x := NegativeInfinity.x
               end
            else
               y.x := r.x
            end
         else
            L.WarningMessage(501,415, "Bel.MF.Numbers.Number.Add")
         end;
         g := Field(y);
         return g
      end Add;

      procedure {public} Subtract (f : object{Field}) : object{Field}
         implements Field.Subtract;
      var
         g : object{Field};
         r, y : Number;
      begin
         if f is Number then
            r := Number(f);
            if IsFinite() & r.IsFinite() then
               y.x := x - r.x
            elsif IsNaN() or r.IsNaN() then
               y.x := NaN.x
            elsif IsPositiveInfinity() then
               if r.IsPositiveInfinity() then
                  y.x := NaN.x
               else
                  y.x := PositiveInfinity.x
               end
            elsif IsNegativeInfinity() then
               if r.IsNegativeInfinity() then
                  y.x := NaN.x
               else
                  y.x := NegativeInfinity.x
               end
            elsif r.IsPositiveInfinity() then
               y.x := NegativeInfinity.x
            else
               y.x := PositiveInfinity.x
            end
         else
            L.WarningMessage(501,415, "Bel.MF.Numbers.Number.Subtract")
         end;
         g := Field(y);
         return g
      end Subtract;

      (* infinities for multiplications and divisions obey: *)
      (*    0 * +/-infinity          -> NaN                 *)
      (*    x * +/-infinity          -> +/-infinity, x > 0  *)
      (*    infinity * +/-infinity   -> +/-infinity         *)
      (*    -infinity * -infinity    -> infinity            *)
      (*    +/-infinity / x          -> +/-infinity, x > 0  *)
      (*    +/-x / infinity          -> 0                   *)
      (*    +/-infinity / infinity   -> NaN                 *)
      (*    0 / 0                    -> NaN                 *)
      (*    +/-x / 0                 -> +/-infinity         *)
      (*    +/-infinity / 0          -> +/-infinity         *)

      procedure {public} Multiply (f : object{Field}) : object{Field}
         implements Field.Multiply;
      var
         g : object{Field};
         r, y : Number;
      begin
         if f is Number then
            r := Number(f);
            if IsFinite() & r.IsFinite() then
               y.x := x * r.x
            elsif IsNaN() or r.IsNaN() then
               y.x := NaN.x
            elsif IsPositiveInfinity() then
               if r.IsInfinite() then
                  y.x := r.x
               elsif zero.CompareTo(r.x) = 0 then
                  y.x := NaN.x
               elsif zero.CompareTo(r.x) < 0 then
                  y.x := PositiveInfinity.x
               else
                  y.x := NegativeInfinity.x
               end
            elsif IsNegativeInfinity() then
               if r.IsNegativeInfinity() then
                  y.x := PositiveInfinity.x
               elsif r.IsPositiveInfinity() then
                  y.x := NegativeInfinity.x
               elsif zero.CompareTo(r.x) = 0 then
                  y.x := NaN.x
               elsif zero.CompareTo(r.x) > 0 then
                  y.x := PositiveInfinity.x
               else
                  y.x := NegativeInfinity.x
               end
            elsif r.IsPositiveInfinity() then
               if zero.CompareTo(x) = 0 then
                  y.x := NaN.x
               elsif zero.CompareTo(x) < 0 then
                  y.x := PositiveInfinity.x
               else
                  y.x := NegativeInfinity.x
               end
            else (* r = NegativeInfinity *)
               if zero.CompareTo(x) = 0 then
                  y.x := NaN.x
               elsif zero.CompareTo(x) > 0 then
                  y.x := PositiveInfinity.x
               else
                  y.x := NegativeInfinity.x
               end
            end
         else
            L.WarningMessage(501,415, "Bel.MF.Numbers.Number.Multiply")
         end;
         g := Field(y);
         return g
      end Multiply;

      procedure {public} Divide (f : object{Field}) : object{Field}
         implements Field.Divide;
      var
         g : object{Field};
         r, y : Number;
      begin
         if f is Number then
            r := Number(f);
            if IsFinite() & r.IsFinite() then
               if zero.CompareTo(x) = 0 then
                  if zero.CompareTo(r.x) = 0 then
                     y.x := NaN.x
                  else
                     y.x := zero
                  end
               elsif zero.CompareTo(r.x) = 0 then
                  if zero.CompareTo(x) < 0 then
                     y.x := PositiveInfinity.x
                  else
                     y.x := NegativeInfinity.x
                  end
               else
                  y.x := x / r.x
               end
            elsif IsNaN() or r.IsNaN() then
               y.x := NaN.x
            elsif IsPositiveInfinity() then
               if r.IsInfinite() then
                  y.x := NaN.x
               elsif zero.CompareTo(r.x) > 0 then
                  y.x := NegativeInfinity.x
               else
                  y.x := PositiveInfinity.x
               end
            elsif IsNegativeInfinity() then
               if r.IsInfinite() then
                  y.x := NaN.x
               elsif zero.CompareTo(r.x) > 0 then
                  y.x := PositiveInfinity.x
               else
                  y.x := NegativeInfinity.x
               end
            else (* r.IsInfinite() *)
               y.x := zero
            end
         else
            L.WarningMessage(501,415, "Bel.MF.Numbers.Number.Divide")
         end;
         g := Field(y);
         return g
      end Divide;

      (* Additional methods not defined via an iterface *)

      (* 'NaN', 'Infinity' and '-Infinity' are allowed *)
      procedure {public} Parse (s : string);
      var
         a : CharArray;
         b : array 36 of char;
         i, j : integer;
         y : string;
      begin
         a := new CharArray(len(s)+2);
         copy(s, a);
         (* pass over any leading white space *)
         j := 0;
         while a[j] = " " do
            inc(j)
         end;
         (* read a contiguous array of characters *)
         i := 0;
         repeat
            b[i] := a[j];
            inc(i);
            inc(j);
         until (a[j] = " ") or (j = len(s));
         (* copy this array into a string *)
         a := new CharArray(i+1);
         for j := 0 to i-1 do
            a[j] := b[j]
         end;
         copy(a, y);
         (* parse *)
         if y = "NaN" then
            x := Real64.NaN
         elsif y = "Infinity" then
            x := Real64.PositiveInfinity
         elsif y = "-Infinity" then
            x := Real64.NegativeInfinity
         else
            x := Real64.Parse(y)
         end
      end Parse;

      procedure {public} Typeset () : string;
      var
         a : CharArray;
         s : string;
      begin
         (* add a space at the front if it is a positive number *)
         if Real64.IsInfinity(x) then
            if Real64.IsPositiveInfinity(x) then
               a := new CharArray(10);
               a[0] := "I";
               a[1] := "n";
               a[2] := "f";
               a[3] := "i";
               a[4] := "n";
               a[5] := "i";
               a[6] := "t";
               a[7] := "y";
               copy(a, s);
               s := " " + s
            else
               a := new CharArray(10);
               a[0] := "-";
               a[1] := "I";
               a[2] := "n";
               a[3] := "f";
               a[4] := "i";
               a[5] := "n";
               a[6] := "i";
               a[7] := "t";
               a[8] := "y";
               copy(a, s)
            end
         elsif Real64.IsNaN(x) then
            a := new CharArray(5);
            a[0] := "N";
            a[1] := "a";
            a[2] := "N";
            copy(a, s);
            s := " " + s
         else
            s := x.ToString("E15");
            if x.CompareTo(zero) >= 0 then
               s := " " + s
            end
         end;
         (* add a space at the end for the parser to catch *)
         s := s + " ";
         return s
      end Typeset;

      procedure {public} ToString (significantDigits : integer) : string;
      var
         a : CharArray;
         s : string;
      begin
         if Real64.IsInfinity(x) then
            if Real64.IsPositiveInfinity(x) then
               a := new CharArray(10);
               a[0] := "I";
               a[1] := "n";
               a[2] := "f";
               a[3] := "i";
               a[4] := "n";
               a[5] := "i";
               a[6] := "t";
               a[7] := "y";
               copy(a, s);
               s := " " + s
            else
               a := new CharArray(10);
               a[0] := "-";
               a[1] := "I";
               a[2] := "n";
               a[3] := "f";
               a[4] := "i";
               a[5] := "n";
               a[6] := "i";
               a[7] := "t";
               a[8] := "y";
               copy(a, s)
            end;
         elsif Real64.IsNaN(x) then
            a := new CharArray(5);
            a[0] := "N";
            a[1] := "a";
            a[2] := "N";
            copy(a, s);
            s := " " + s
         else
            if significantDigits > 8 then
               if significantDigits > 12 then
                  if significantDigits = 13 then
                     s := x.ToString("E13")
                  elsif significantDigits = 14 then
                     s := x.ToString("E14")
                  else
                     s := x.ToString("E15")
                  end
               else
                  if significantDigits = 9 then
                     s := x.ToString("E9")
                  elsif significantDigits = 10 then
                     s := x.ToString("E10")
                  elsif significantDigits = 11 then
                     s := x.ToString("E11")
                  else
                     s := x.ToString("E12")
                  end
               end
            else
               if significantDigits < 5 then
                  if significantDigits = 4 then
                     s := x.ToString("E4")
                  elsif significantDigits = 3 then
                     s := x.ToString("E3")
                  else
                     s := x.ToString("E2")
                  end
               else
                  if significantDigits = 8 then
                     s := x.ToString("E8")
                  elsif significantDigits = 7 then
                     s := x.ToString("E7")
                  elsif significantDigits = 6 then
                     s := x.ToString("E6")
                  else
                     s := x.ToString("E5")
                  end
               end
            end;
            (* add a space at the front if it is a positive number *)
            if x.CompareTo(zero) >= 0 then
               s := " " + s
            end
         end;
         (* add a space at the end for the parser to catch *)
         s := s + " ";
         return s
      end ToString;

      procedure {public} Get () : NumberType;
      var
         y : Real64;
      begin
         y := x;
         return y
      end Get;

      procedure {public} Set (r : NumberType);
      begin
         x := r
      end Set;

      procedure {public} IsFinite () : boolean;
      begin
         return (~Real64.IsInfinity(x) & ~Real64.IsNaN(x))
      end IsFinite;

      procedure {public} IsInfinite () : boolean;
      begin
         return Real64.IsInfinity(x)
      end IsInfinite;

      procedure {public} IsPositiveInfinity () : boolean;
      begin
         return Real64.IsPositiveInfinity(x)
      end IsPositiveInfinity;

      procedure {public} IsNegativeInfinity () : boolean;
      begin
         return Real64.IsNegativeInfinity(x)
      end IsNegativeInfinity;

      procedure {public} IsNaN () : boolean;
      begin
         return Real64.IsNaN(x)
      end IsNaN;

(*    boolean truths assigned to +/-infinity obey:                            *)
(*       infinity = infinity  and  -infinity = -infinity                      *)
(*    all boolean operators return 'false' whenever one or both arguments is  *)
(*    a NaN, i.e., the operation is undefined. Consequently, one cannot check *)
(*    to see if a Number is NaN by calling x.Equals(NaN); it will always      *)
(*    return 'false'. Instead, one must call x.IsNaN() to discern if 'x' is   *)
(*    NaN. In contrast, x.Equals(PositiveInfinity) returns 'true' if 'x' is   *)
(*    PositiveInfinity.                                                       *)

      procedure {public} Equals (n : Number) : boolean;
      var
         diff : Real64;
      begin
         if IsFinite() & n.IsFinite() then
            diff := x - n.x;
            if diff.CompareTo(zero) < 0 then
               diff := zero - diff;
            end;
            (* Real64.Epsilon is what I call MinimumPositiveNumber *)
            if diff.CompareTo(Real64.Epsilon) < 0 then
               return true
            else
               return false
            end
         else
            if IsNaN() or n.IsNaN() then
               return false
            end;
            if IsPositiveInfinity() & n.IsPositiveInfinity() then
               return true
            elsif IsNegativeInfinity() & n.IsNegativeInfinity() then
               return true
            else
               return false
            end
         end
      end Equals;

      procedure {public} NotEqual (n : Number) : boolean;
      var
         diff : Real64;
      begin
         if IsFinite() & n.IsFinite() then
            diff := x - n.x;
            if diff.CompareTo(zero) < 0 then
               diff := zero - diff;
            end;
            (* Real64.Epsilon is what I call MinimumPositiveNumber *)
            if diff.CompareTo(Real64.Epsilon) > 0 then
               return true
            else
               return false
            end
         else
            if IsNaN() or n.IsNaN() then
               return false
            end;
            if IsPositiveInfinity() & n.IsPositiveInfinity() then
               return false
            elsif IsNegativeInfinity() & n.IsNegativeInfinity() then
               return false
            else
               return true
            end
         end
      end NotEqual;

      procedure {public} LessThan (n : Number) : boolean;
      begin
         if IsFinite() & n.IsFinite() then
            if x.CompareTo(n.x) < 0 then
               return true
            else
               return false
            end
         else
            if IsNaN() or n.IsNaN() then
               return false
            end;
            if IsPositiveInfinity() then
               return false
            elsif n.IsNegativeInfinity() then
               return false
            else
               return true
            end
         end
      end LessThan;

      procedure {public} LessThanOrEqual (n : Number) : boolean;
      begin
         if IsFinite() & n.IsFinite() then
            if x.CompareTo(n.x) > 0 then
               return false
            else
               return true
            end
         else
            if IsNaN() or n.IsNaN() then
               return false
            end;
            if IsNegativeInfinity() then
               return true
            elsif n.IsPositiveInfinity() then
               return true
            else
               return false
            end
         end
      end LessThanOrEqual;

      procedure {public} GreaterThan (n : Number) : boolean;
      begin
         if IsFinite() & n.IsFinite() then
            if x.CompareTo(n.x) > 0 then
               return true
            else
               return false
            end
         else
            if IsNaN() or n.IsNaN() then
               return false
            end;
            if IsNegativeInfinity() then
               return false
            elsif n.IsPositiveInfinity() then
               return false
            else
               return true
            end
         end
      end GreaterThan;

      procedure {public} GreaterThanOrEqual (n : Number) : boolean;
      begin
         if IsFinite() & n.IsFinite() then
            if x.CompareTo(n.x) < 0 then
               return false
            else
               return true
            end
         else
            if IsNaN() or n.IsNaN() then
               return false
            end;
            if IsPositiveInfinity() then
               return true
            elsif n.IsNegativeInfinity() then
               return true
            else
               return false
            end
         end
      end GreaterThanOrEqual;

      procedure {public} Magnitude () : Number;
      var
         y : Number;
      begin
         if IsNaN() then
            y.x := NaN.x
         elsif IsInfinite() then
            y.x := PositiveInfinity.x
         else
            if x.CompareTo(zero) < 0 then
               y.x := zero - x
            else
               y.x := x
            end
         end;
         return y
      end Magnitude;

      (* infinities and nan's for exponentiation obey:          *)
      (*    x ** y            -> NaN          x < 0             *)
      (*    x ** 0            -> 1            0 < x < infinity  *)
      (*    x ** infinity     -> infinity     0 < x <= infinity *)
      (*    x ** -infinity    -> 0            0 < x <= infinity *)
      (*    0 ** y            -> 0            0 < y < infinity  *)
      (*    0 ** -y           -> infinity     0 < y < infinity  *)
      (*    0 ** 0            -> NaN                            *)
      (*    0 ** +/-infinity  -> NaN                            *)
      (*    infinity ** 0     -> NaN                            *)
      (*    infinity ** y     -> infinity     0 < y < infinity  *)
      (*    infinity ** -y    -> 0            0 < y < infinity  *)

      procedure {public} Power (exponent : Number) : Number;
      var
         y : Number;
      begin
         if IsFinite() & exponent.IsFinite() then
            if zero.CompareTo(x) < 0 then
               if zero.CompareTo(exponent.x) = 0 then
                  y.x := one
               else
                  y.x := Math.Pow(x, exponent.x)
               end
            elsif zero.CompareTo(x) = 0 then
               if zero.CompareTo(exponent.x) < 0 then
                  y.x := zero
               elsif zero.CompareTo(exponent.x) > 0 then
                  y.x := PositiveInfinity.x
               else
                  y.x := NaN.x
               end
            else
               y.x := NaN.x
            end
         elsif IsNaN() or exponent.IsNaN() then
            y.x := NaN.x
         elsif IsPositiveInfinity() then
            if exponent.IsInfinite() then
               if exponent.IsPositiveInfinity() then
                  y.x := PositiveInfinity.x
               else
                  y.x := NaN.x
               end
            elsif zero.CompareTo(exponent.x) < 0 then
               y.x := PositiveInfinity.x
            elsif zero.CompareTo(exponent.x) = 0 then
               y.x := NaN.x
            else
               y.x := zero
            end
         elsif IsNegativeInfinity() then
            y.x := NaN.x
         elsif exponent.IsPositiveInfinity() then
            if zero.CompareTo(x) < 0 then
               y.x := PositiveInfinity.x
            else
               y.x := NaN.x
            end
         else (* r = NegativeInfinity *)
            if zero.CompareTo(x) < 0 then
               y.x := zero
            else
               y.x := NaN.x
            end
         end;
         return y
      end Power;

   begin
      Initialize
   end Number;

   (* type conversion procedures to the base, internal, data type *)

   procedure {private} Card8ToNumberType (x : Card8) : NumberType;
   var
      n : NumberType;
   begin
      n := Convert.ToDouble(x);
      return n
   end Card8ToNumberType;

   procedure {private} Card16ToNumberType (x : Card16) : NumberType;
   var
      n : NumberType;
   begin
      n := Convert.ToDouble(x);
      return n
   end Card16ToNumberType;

   procedure {private} Card32ToNumberType (x : Card32) : NumberType;
   var
      n : NumberType;
   begin
      n := Convert.ToDouble(x);
      return n
   end Card32ToNumberType;

   procedure {private} Card64ToNumberType (x : Card64) : NumberType;
   var
      n : NumberType;
   begin
      n := Convert.ToDouble(x);
      return n
   end Card64ToNumberType;

   procedure {private} Int8ToNumberType (x : Int8) : NumberType;
   var
      n : NumberType;
   begin
      n := Convert.ToDouble(x);
      return n
   end Int8ToNumberType;

   procedure {private} Int16ToNumberType (x : Int16) : NumberType;
   var
      n : NumberType;
   begin
      n := Convert.ToDouble(x);
      return n
   end Int16ToNumberType;

   procedure {private} Int32ToNumberType (x : Int32) : NumberType;
   var
      n : NumberType;
   begin
      n := Convert.ToDouble(x);
      return n
   end Int32ToNumberType;

   procedure {private} Int64ToNumberType (x : Int64) : NumberType;
   var
      n : NumberType;
   begin
      n := Convert.ToDouble(x);
      return n
   end Int64ToNumberType;

   procedure {private} Real32ToNumberType (x : Real32) : NumberType;
   var
      n : NumberType;
   begin
      if ~Real32.IsInfinity(x) & ~Real32.IsNaN(x) then
         (* this appends zeros to the 8 least significant digits; whereas, *)
         (* using System.Convert.ToDouble does not, in either .NET or mono *)
         n := Real64.Parse(x.ToString())
      elsif Real32.IsPositiveInfinity(x) then
         n := Real64.PositiveInfinity
      elsif Real32.IsNegativeInfinity(x) then
         n := Real64.NegativeInfinity
      else
         n := Real64.NaN
      end;
      return n
   end Real32ToNumberType;

   procedure {private} Real64ToNumberType (x : Real64) : NumberType;
   begin
      return x
   end Real64ToNumberType;

   procedure {private} StringToNumberType (x : string) : NumberType;
   var
      n : NumberType;
   begin
      n := Real64.Parse(x);
      return n
   end StringToNumberType;

   (* OVERLOADED OPERATORS *)
   (* places wrappers around the associated real methods *)

   (* assignment *)

   operator {public} ':=' (var l : Number; r : Number);
   begin
      l.Set(r.Get())
   end ':=';

   operator {public} ':=' (var l : Number; r : Real64);
   begin
      l.Set(Real64ToNumberType(r))
   end ':=';

   operator {public} ':=' (var l : Number; r : Real32);
   begin
      l.Set(Real32ToNumberType(r))
   end ':=';

   operator {public} ':=' (var l : Number; r : Card64);
   begin
      l.Set(Card64ToNumberType(r))
   end ':=';

   operator {public} ':=' (var l : Number; r : Card32);
   begin
      l.Set(Card32ToNumberType(r))
   end ':=';

   operator {public} ':=' (var l : Number; r : Card16);
   begin
      l.Set(Card16ToNumberType(r))
   end ':=';

   operator {public} ':=' (var l : Number; r : Card8);
   begin
      l.Set(Card8ToNumberType(r))
   end ':=';

   operator {public} ':=' (var l : Number; r : Int64);
   begin
      l.Set(Int64ToNumberType(r))
   end ':=';

   operator {public} ':=' (var l : Number; r : Int32);
   begin
      l.Set(Int32ToNumberType(r))
   end ':=';

   operator {public} ':=' (var l : Number; r : Int16);
   begin
      l.Set(Int16ToNumberType(r))
   end ':=';

   operator {public} ':=' (var l : Number; r : Int8);
   begin
      l.Set(Int8ToNumberType(r))
   end ':=';

   operator {public} ':=' (var l : Number; r : string);
   begin
      l.Set(StringToNumberType(r))
   end ':=';

   (* unary operator *)

   operator {public} '-' (x : Number) : Number;
   begin
      return Number(x.Negative())
   end '-';

   (* logic operators *)

   operator {public} '=' (l, r : Number) : boolean;
   begin
      return l.Equals(r)
   end '=';

   operator {public} '=' (l : Number; r : Real64) : boolean;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(r));
      return l.Equals(n)
   end '=';

   operator {public} '=' (l : Number; r : Real32) : boolean;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(r));
      return l.Equals(n)
   end '=';

   operator {public} '=' (l : Number; r : Card64) : boolean;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(r));
      return l.Equals(n)
   end '=';

   operator {public} '=' (l : Number; r : Card32) : boolean;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(r));
      return l.Equals(n)
   end '=';

   operator {public} '=' (l : Number; r : Card16) : boolean;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(r));
      return l.Equals(n)
   end '=';

   operator {public} '=' (l : Number; r : Card8) : boolean;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(r));
      return l.Equals(n)
   end '=';

   operator {public} '=' (l : Number; r : Int64) : boolean;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(r));
      return l.Equals(n)
   end '=';

   operator {public} '=' (l : Number; r : Int32) : boolean;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(r));
      return l.Equals(n)
   end '=';

   operator {public} '=' (l : Number; r : Int16) : boolean;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(r));
      return l.Equals(n)
   end '=';

   operator {public} '=' (l : Number; r : Int8) : boolean;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(r));
      return l.Equals(n)
   end '=';

   operator {public} '=' (l : Number; r : string) : boolean;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(r));
      return l.Equals(n)
   end '=';

   operator {public} '=' (l : Real64; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(l));
      return n.Equals(r)
   end '=';

   operator {public} '=' (l : Real32; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(l));
      return n.Equals(r)
   end '=';

   operator {public} '=' (l : Card64; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(l));
      return n.Equals(r)
   end '=';

   operator {public} '=' (l : Card32; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(l));
      return n.Equals(r)
   end '=';

   operator {public} '=' (l : Card16; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(l));
      return n.Equals(r)
   end '=';

   operator {public} '=' (l : Card8; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(l));
      return n.Equals(r)
   end '=';

   operator {public} '=' (l : Int64; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(l));
      return n.Equals(r)
   end '=';

   operator {public} '=' (l : Int32; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(l));
      return n.Equals(r)
   end '=';

   operator {public} '=' (l : Int16; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(l));
      return n.Equals(r)
   end '=';

   operator {public} '=' (l : Int8; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(l));
      return n.Equals(r)
   end '=';

   operator {public} '=' (l : string; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(l));
      return n.Equals(r)
   end '=';

   operator {public} '#' (l, r : Number) : boolean;
   begin
      return l.NotEqual(r)
   end '#';

   operator {public} '#' (l : Number; r : Real64) : boolean;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(r));
      return l.NotEqual(n)
   end '#';

   operator {public} '#' (l : Number; r : Real32) : boolean;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(r));
      return l.NotEqual(n)
   end '#';

   operator {public} '#' (l : Number; r : Card64) : boolean;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(r));
      return l.NotEqual(n)
   end '#';

   operator {public} '#' (l : Number; r : Card32) : boolean;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(r));
      return l.NotEqual(n)
   end '#';

   operator {public} '#' (l : Number; r : Card16) : boolean;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(r));
      return l.NotEqual(n)
   end '#';

   operator {public} '#' (l : Number; r : Card8) : boolean;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(r));
      return l.NotEqual(n)
   end '#';

   operator {public} '#' (l : Number; r : Int64) : boolean;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(r));
      return l.NotEqual(n)
   end '#';

   operator {public} '#' (l : Number; r : Int32) : boolean;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(r));
      return l.NotEqual(n)
   end '#';

   operator {public} '#' (l : Number; r : Int16) : boolean;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(r));
      return l.NotEqual(n)
   end '#';

   operator {public} '#' (l : Number; r : Int8) : boolean;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(r));
      return l.NotEqual(n)
   end '#';

   operator {public} '#' (l : Number; r : string) : boolean;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(r));
      return l.NotEqual(n)
   end '#';

   operator {public} '#' (l : Real64; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(l));
      return n.NotEqual(r)
   end '#';

   operator {public} '#' (l : Real32; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(l));
      return n.NotEqual(r)
   end '#';

   operator {public} '#' (l : Card64; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(l));
      return n.NotEqual(r)
   end '#';

   operator {public} '#' (l : Card32; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(l));
      return n.NotEqual(r)
   end '#';

   operator {public} '#' (l : Card16; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(l));
      return n.NotEqual(r)
   end '#';

   operator {public} '#' (l : Card8; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(l));
      return n.NotEqual(r)
   end '#';

   operator {public} '#' (l : Int64; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(l));
      return n.NotEqual(r)
   end '#';

   operator {public} '#' (l : Int32; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(l));
      return n.NotEqual(r)
   end '#';

   operator {public} '#' (l : Int16; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(l));
      return n.NotEqual(r)
   end '#';

   operator {public} '#' (l : Int8; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(l));
      return n.NotEqual(r)
   end '#';

   operator {public} '#' (l : string; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(l));
      return n.NotEqual(r)
   end '#';

   operator {public} '<' (l, r : Number) : boolean;
   begin
      return l.LessThan(r)
   end '<';

   operator {public} '<' (l : Number; r : Real64) : boolean;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(r));
      return l.LessThan(n)
   end '<';

   operator {public} '<' (l : Number; r : Real32) : boolean;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(r));
      return l.LessThan(n)
   end '<';

   operator {public} '<' (l : Number; r : Card64) : boolean;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(r));
      return l.LessThan(n)
   end '<';

   operator {public} '<' (l : Number; r : Card32) : boolean;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(r));
      return l.LessThan(n)
   end '<';

   operator {public} '<' (l : Number; r : Card16) : boolean;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(r));
      return l.LessThan(n)
   end '<';

   operator {public} '<' (l : Number; r : Card8) : boolean;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(r));
      return l.LessThan(n)
   end '<';

   operator {public} '<' (l : Number; r : Int64) : boolean;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(r));
      return l.LessThan(n)
   end '<';

   operator {public} '<' (l : Number; r : Int32) : boolean;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(r));
      return l.LessThan(n)
   end '<';

   operator {public} '<' (l : Number; r : Int16) : boolean;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(r));
      return l.LessThan(n)
   end '<';

   operator {public} '<' (l : Number; r : Int8) : boolean;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(r));
      return l.LessThan(n)
   end '<';

   operator {public} '<' (l : Number; r : string) : boolean;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(r));
      return l.LessThan(n)
   end '<';

   operator {public} '<' (l : Real64; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(l));
      return n.LessThan(r)
   end '<';

   operator {public} '<' (l : Real32; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(l));
      return n.LessThan(r)
   end '<';

   operator {public} '<' (l : Card64; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(l));
      return n.LessThan(r)
   end '<';

   operator {public} '<' (l : Card32; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(l));
      return n.LessThan(r)
   end '<';

   operator {public} '<' (l : Card16; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(l));
      return n.LessThan(r)
   end '<';

   operator {public} '<' (l : Card8; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(l));
      return n.LessThan(r)
   end '<';

   operator {public} '<' (l : Int64; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(l));
      return n.LessThan(r)
   end '<';

   operator {public} '<' (l : Int32; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(l));
      return n.LessThan(r)
   end '<';

   operator {public} '<' (l : Int16; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(l));
      return n.LessThan(r)
   end '<';

   operator {public} '<' (l : Int8; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(l));
      return n.LessThan(r)
   end '<';

   operator {public} '<' (l : string; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(l));
      return n.LessThan(r)
   end '<';

   operator {public} '<=' (l, r : Number) : boolean;
   begin
      return l.LessThanOrEqual(r)
   end '<=';

   operator {public} '<=' (l : Number; r : Real64) : boolean;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(r));
      return l.LessThanOrEqual(n)
   end '<=';

   operator {public} '<=' (l : Number; r : Real32) : boolean;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(r));
      return l.LessThanOrEqual(n)
   end '<=';

   operator {public} '<=' (l : Number; r : Card64) : boolean;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(r));
      return l.LessThanOrEqual(n)
   end '<=';

   operator {public} '<=' (l : Number; r : Card32) : boolean;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(r));
      return l.LessThanOrEqual(n)
   end '<=';

   operator {public} '<=' (l : Number; r : Card16) : boolean;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(r));
      return l.LessThanOrEqual(n)
   end '<=';

   operator {public} '<=' (l : Number; r : Card8) : boolean;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(r));
      return l.LessThanOrEqual(n)
   end '<=';

   operator {public} '<=' (l : Number; r : Int64) : boolean;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(r));
      return l.LessThanOrEqual(n)
   end '<=';

   operator {public} '<=' (l : Number; r : Int32) : boolean;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(r));
      return l.LessThanOrEqual(n)
   end '<=';

   operator {public} '<=' (l : Number; r : Int16) : boolean;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(r));
      return l.LessThanOrEqual(n)
   end '<=';

   operator {public} '<=' (l : Number; r : Int8) : boolean;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(r));
      return l.LessThanOrEqual(n)
   end '<=';

   operator {public} '<=' (l : Number; r : string) : boolean;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(r));
      return l.LessThanOrEqual(n)
   end '<=';

   operator {public} '<=' (l : Real64; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(l));
      return n.LessThanOrEqual(r)
   end '<=';

   operator {public} '<=' (l : Real32; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(l));
      return n.LessThanOrEqual(r)
   end '<=';

   operator {public} '<=' (l : Card64; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(l));
      return n.LessThanOrEqual(r)
   end '<=';

   operator {public} '<=' (l : Card32; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(l));
      return n.LessThanOrEqual(r)
   end '<=';

   operator {public} '<=' (l : Card16; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(l));
      return n.LessThanOrEqual(r)
   end '<=';

   operator {public} '<=' (l : Card8; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(l));
      return n.LessThanOrEqual(r)
   end '<=';

   operator {public} '<=' (l : Int64; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(l));
      return n.LessThanOrEqual(r)
   end '<=';

   operator {public} '<=' (l : Int32; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(l));
      return n.LessThanOrEqual(r)
   end '<=';

   operator {public} '<=' (l : Int16; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(l));
      return n.LessThanOrEqual(r)
   end '<=';

   operator {public} '<=' (l : Int8; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(l));
      return n.LessThanOrEqual(r)
   end '<=';

   operator {public} '<=' (l : string; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(l));
      return n.LessThanOrEqual(r)
   end '<=';

   operator {public} '>' (l, r : Number) : boolean;
   begin
      return l.GreaterThan(r)
   end '>';

   operator {public} '>' (l : Number; r : Real64) : boolean;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(r));
      return l.GreaterThan(n)
   end '>';

   operator {public} '>' (l : Number; r : Real32) : boolean;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(r));
      return l.GreaterThan(n)
   end '>';

   operator {public} '>' (l : Number; r : Card64) : boolean;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(r));
      return l.GreaterThan(n)
   end '>';

   operator {public} '>' (l : Number; r : Card32) : boolean;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(r));
      return l.GreaterThan(n)
   end '>';

   operator {public} '>' (l : Number; r : Card16) : boolean;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(r));
      return l.GreaterThan(n)
   end '>';

   operator {public} '>' (l : Number; r : Card8) : boolean;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(r));
      return l.GreaterThan(n)
   end '>';

   operator {public} '>' (l : Number; r : Int64) : boolean;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(r));
      return l.GreaterThan(n)
   end '>';

   operator {public} '>' (l : Number; r : Int32) : boolean;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(r));
      return l.GreaterThan(n)
   end '>';

   operator {public} '>' (l : Number; r : Int16) : boolean;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(r));
      return l.GreaterThan(n)
   end '>';

   operator {public} '>' (l : Number; r : Int8) : boolean;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(r));
      return l.GreaterThan(n)
   end '>';

   operator {public} '>' (l : Number; r : string) : boolean;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(r));
      return l.GreaterThan(n)
   end '>';

   operator {public} '>' (l : Real64; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(l));
      return n.GreaterThan(r)
   end '>';

   operator {public} '>' (l : Real32; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(l));
      return n.GreaterThan(r)
   end '>';

   operator {public} '>' (l : Card64; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(l));
      return n.GreaterThan(r)
   end '>';

   operator {public} '>' (l : Card32; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(l));
      return n.GreaterThan(r)
   end '>';

   operator {public} '>' (l : Card16; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(l));
      return n.GreaterThan(r)
   end '>';

   operator {public} '>' (l : Card8; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(l));
      return n.GreaterThan(r)
   end '>';

   operator {public} '>' (l : Int64; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(l));
      return n.GreaterThan(r)
   end '>';

   operator {public} '>' (l : Int32; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(l));
      return n.GreaterThan(r)
   end '>';

   operator {public} '>' (l : Int16; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(l));
      return n.GreaterThan(r)
   end '>';

   operator {public} '>' (l : Int8; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(l));
      return n.GreaterThan(r)
   end '>';

   operator {public} '>' (l : string; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(l));
      return n.GreaterThan(r)
   end '>';

   operator {public} '>=' (l, r : Number) : boolean;
   begin
      return l.GreaterThanOrEqual(r)
   end '>=';

   operator {public} '>=' (l : Number; r : Real64) : boolean;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(r));
      return l.GreaterThanOrEqual(n)
   end '>=';

   operator {public} '>=' (l : Number; r : Real32) : boolean;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(r));
      return l.GreaterThanOrEqual(n)
   end '>=';

   operator {public} '>=' (l : Number; r : Card64) : boolean;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(r));
      return l.GreaterThanOrEqual(n)
   end '>=';

   operator {public} '>=' (l : Number; r : Card32) : boolean;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(r));
      return l.GreaterThanOrEqual(n)
   end '>=';

   operator {public} '>=' (l : Number; r : Card16) : boolean;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(r));
      return l.GreaterThanOrEqual(n)
   end '>=';

   operator {public} '>=' (l : Number; r : Card8) : boolean;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(r));
      return l.GreaterThanOrEqual(n)
   end '>=';

   operator {public} '>=' (l : Number; r : Int64) : boolean;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(r));
      return l.GreaterThanOrEqual(n)
   end '>=';

   operator {public} '>=' (l : Number; r : Int32) : boolean;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(r));
      return l.GreaterThanOrEqual(n)
   end '>=';

   operator {public} '>=' (l : Number; r : Int16) : boolean;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(r));
      return l.GreaterThanOrEqual(n)
   end '>=';

   operator {public} '>=' (l : Number; r : Int8) : boolean;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(r));
      return l.GreaterThanOrEqual(n)
   end '>=';

   operator {public} '>=' (l : Number; r : string) : boolean;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(r));
      return l.GreaterThanOrEqual(n)
   end '>=';

   operator {public} '>=' (l : Real64; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(l));
      return n.GreaterThanOrEqual(r)
   end '>=';

   operator {public} '>=' (l : Real32; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(l));
      return n.GreaterThanOrEqual(r)
   end '>=';

   operator {public} '>=' (l : Card64; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(l));
      return n.GreaterThanOrEqual(r)
   end '>=';

   operator {public} '>=' (l : Card32; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(l));
      return n.GreaterThanOrEqual(r)
   end '>=';

   operator {public} '>=' (l : Card16; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(l));
      return n.GreaterThanOrEqual(r)
   end '>=';

   operator {public} '>=' (l : Card8; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(l));
      return n.GreaterThanOrEqual(r)
   end '>=';

   operator {public} '>=' (l : Int64; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(l));
      return n.GreaterThanOrEqual(r)
   end '>=';

   operator {public} '>=' (l : Int32; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(l));
      return n.GreaterThanOrEqual(r)
   end '>=';

   operator {public} '>=' (l : Int16; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(l));
      return n.GreaterThanOrEqual(r)
   end '>=';

   operator {public} '>=' (l : Int8; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(l));
      return n.GreaterThanOrEqual(r)
   end '>=';

   operator {public} '>=' (l : string; r : Number) : boolean;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(l));
      return n.GreaterThanOrEqual(r)
   end '>=';

   (* arithemtic operators *)

   operator {public} '+' (l, r : Number) : Number;
   begin
      return Number(l.Add(r))
   end '+';

   operator {public} '+' (l : Number; r : Real64) : Number;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(r));
      return Number(l.Add(n))
   end '+';

   operator {public} '+' (l : Number; r : Real32) : Number;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(r));
      return Number(l.Add(n))
   end '+';

   operator {public} '+' (l : Number; r : Card64) : Number;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(r));
      return Number(l.Add(n))
   end '+';

   operator {public} '+' (l : Number; r : Card32) : Number;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(r));
      return Number(l.Add(n))
   end '+';

   operator {public} '+' (l : Number; r : Card16) : Number;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(r));
      return Number(l.Add(n))
   end '+';

   operator {public} '+' (l : Number; r : Card8) : Number;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(r));
      return Number(l.Add(n))
   end '+';

   operator {public} '+' (l : Number; r : Int64) : Number;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(r));
      return Number(l.Add(n))
   end '+';

   operator {public} '+' (l : Number; r : Int32) : Number;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(r));
      return Number(l.Add(n))
   end '+';

   operator {public} '+' (l : Number; r : Int16) : Number;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(r));
      return Number(l.Add(n))
   end '+';

   operator {public} '+' (l : Number; r : Int8) : Number;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(r));
      return Number(l.Add(n))
   end '+';

   operator {public} '+' (l : Number; r : string) : Number;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(r));
      return Number(l.Add(n))
   end '+';

   operator {public} '+' (l : Real64; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(l));
      return Number(n.Add(r))
   end '+';

   operator {public} '+' (l : Real32; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(l));
      return Number(n.Add(r))
   end '+';

   operator {public} '+' (l : Card64; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(l));
      return Number(n.Add(r))
   end '+';

   operator {public} '+' (l : Card32; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(l));
      return Number(n.Add(r))
   end '+';

   operator {public} '+' (l : Card16; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(l));
      return Number(n.Add(r))
   end '+';

   operator {public} '+' (l : Card8; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(l));
      return Number(n.Add(r))
   end '+';

   operator {public} '+' (l : Int64; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(l));
      return Number(n.Add(r))
   end '+';

   operator {public} '+' (l : Int32; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(l));
      return Number(n.Add(r))
   end '+';

   operator {public} '+' (l : Int16; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(l));
      return Number(n.Add(r))
   end '+';

   operator {public} '+' (l : Int8; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(l));
      return Number(n.Add(r))
   end '+';

   operator {public} '+' (l : string; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(l));
      return Number(n.Add(r))
   end '+';

   operator {public} '-' (l, r : Number) : Number;
   begin
      return Number(l.Subtract(r))
   end '-';

   operator {public} '-' (l : Number; r : Real64): Number;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(r));
      return Number(l.Subtract(n))
   end '-';

   operator {public} '-' (l : Number; r : Real32): Number;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(r));
      return Number(l.Subtract(n))
   end '-';

   operator {public} '-' (l : Number; r : Card64) : Number;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(r));
      return Number(l.Subtract(n))
   end '-';

   operator {public} '-' (l : Number; r : Card32) : Number;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(r));
      return Number(l.Subtract(n))
   end '-';

   operator {public} '-' (l : Number; r : Card16) : Number;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(r));
      return Number(l.Subtract(n))
   end '-';

   operator {public} '-' (l : Number; r : Card8) : Number;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(r));
      return Number(l.Subtract(n))
   end '-';

   operator {public} '-' (l : Number; r : Int64) : Number;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(r));
      return Number(l.Subtract(n))
   end '-';

   operator {public} '-' (l : Number; r : Int32) : Number;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(r));
      return Number(l.Subtract(n))
   end '-';

   operator {public} '-' (l : Number; r : Int16) : Number;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(r));
      return Number(l.Subtract(n))
   end '-';

   operator {public} '-' (l : Number; r : Int8) : Number;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(r));
      return Number(l.Subtract(n))
   end '-';

   operator {public} '-' (l : Number; r : string) : Number;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(r));
      return Number(l.Subtract(n))
   end '-';

   operator {public} '-' (l : Real64; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(l));
      return Number(n.Subtract(r))
   end '-';

   operator {public} '-' (l : Real32; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(l));
      return Number(n.Subtract(r))
   end '-';

   operator {public} '-' (l : Card64; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(l));
      return Number(n.Subtract(r))
   end '-';

   operator {public} '-' (l : Card32; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(l));
      return Number(n.Subtract(r))
   end '-';

   operator {public} '-' (l : Card16; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(l));
      return Number(n.Subtract(r))
   end '-';

   operator {public} '-' (l : Card8; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(l));
      return Number(n.Subtract(r))
   end '-';

   operator {public} '-' (l : Int64; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(l));
      return Number(n.Subtract(r))
   end '-';

   operator {public} '-' (l : Int32; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(l));
      return Number(n.Subtract(r))
   end '-';

   operator {public} '-' (l : Int16; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(l));
      return Number(n.Subtract(r))
   end '-';

   operator {public} '-' (l : Int8; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(l));
      return Number(n.Subtract(r))
   end '-';

   operator {public} '-' (l : string; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(l));
      return Number(n.Subtract(r))
   end '-';

   operator {public} '*' (l, r : Number) : Number;
   begin
      return Number(l.Multiply(r))
   end '*';

   operator {public} '*' (l : Number; r : Real64) : Number;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(r));
      return Number(l.Multiply(n))
   end '*';

   operator {public} '*' (l : Number; r : Real32) : Number;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(r));
      return Number(l.Multiply(n))
   end '*';

   operator {public} '*' (l : Number; r : Card64) : Number;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(r));
      return Number(l.Multiply(n))
   end '*';

   operator {public} '*' (l : Number; r : Card32) : Number;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(r));
      return Number(l.Multiply(n))
   end '*';

   operator {public} '*' (l : Number; r : Card16) : Number;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(r));
      return Number(l.Multiply(n))
   end '*';

   operator {public} '*' (l : Number; r : Card8) : Number;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(r));
      return Number(l.Multiply(n))
   end '*';

   operator {public} '*' (l : Number; r : Int64) : Number;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(r));
      return Number(l.Multiply(n))
   end '*';

   operator {public} '*' (l : Number; r : Int32) : Number;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(r));
      return Number(l.Multiply(n))
   end '*';

   operator {public} '*' (l : Number; r : Int16) : Number;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(r));
      return Number(l.Multiply(n))
   end '*';

   operator {public} '*' (l : Number; r : Int8) : Number;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(r));
      return Number(l.Multiply(n))
   end '*';

   operator {public} '*' (l : Number; r : string) : Number;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(r));
      return Number(l.Multiply(n))
   end '*';

   operator {public} '*' (l : Real64; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(l));
      return Number(n.Multiply(r))
   end '*';

   operator {public} '*' (l : Real32; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(l));
      return Number(n.Multiply(r))
   end '*';

   operator {public} '*' (l : Card64; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(l));
      return Number(n.Multiply(r))
   end '*';

   operator {public} '*' (l : Card32; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(l));
      return Number(n.Multiply(r))
   end '*';

   operator {public} '*' (l : Card16; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(l));
      return Number(n.Multiply(r))
   end '*';

   operator {public} '*' (l : Card8; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(l));
      return Number(n.Multiply(r))
   end '*';

   operator {public} '*' (l : Int64; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(l));
      return Number(n.Multiply(r))
   end '*';

   operator {public} '*' (l : Int32; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(l));
      return Number(n.Multiply(r))
   end '*';

   operator {public} '*' (l : Int16; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(l));
      return Number(n.Multiply(r))
   end '*';

   operator {public} '*' (l : Int8; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(l));
      return Number(n.Multiply(r))
   end '*';

   operator {public} '*' (l : string; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(l));
      return Number(n.Multiply(r))
   end '*';

   operator {public} '/' (l, r : Number) : Number;
   begin
      return Number(l.Divide(r))
   end '/';

   operator {public} '/' (l : Number; r : Real64) : Number;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(r));
      return Number(l.Divide(n))
   end '/';

   operator {public} '/' (l : Number; r : Real32) : Number;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(r));
      return Number(l.Divide(n))
   end '/';

   operator {public} '/' (l : Number; r : Card64) : Number;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(r));
      return Number(l.Divide(n))
   end '/';

   operator {public} '/' (l : Number; r : Card32) : Number;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(r));
      return Number(l.Divide(n))
   end '/';

   operator {public} '/' (l : Number; r : Card16) : Number;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(r));
      return Number(l.Divide(n))
   end '/';

   operator {public} '/' (l : Number; r : Card8) : Number;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(r));
      return Number(l.Divide(n))
   end '/';

   operator {public} '/' (l : Number; r : Int64) : Number;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(r));
      return Number(l.Divide(n))
   end '/';

   operator {public} '/' (l : Number; r : Int32) : Number;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(r));
      return Number(l.Divide(n))
   end '/';

   operator {public} '/' (l : Number; r : Int16) : Number;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(r));
      return Number(l.Divide(n))
   end '/';

   operator {public} '/' (l : Number; r : Int8) : Number;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(r));
      return Number(l.Divide(n))
   end '/';

   operator {public} '/' (l : Number; r : string) : Number;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(r));
      return Number(l.Divide(n))
   end '/';

   operator {public} '/' (l : Real64; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(l));
      return Number(n.Divide(r))
   end '/';

   operator {public} '/' (l : Real32; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(l));
      return Number(n.Divide(r))
   end '/';

   operator {public} '/' (l : Card64; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(l));
      return Number(n.Divide(r))
   end '/';

   operator {public} '/' (l : Card32; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(l));
      return Number(n.Divide(r))
   end '/';

   operator {public} '/' (l : Card16; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(l));
      return Number(n.Divide(r))
   end '/';

   operator {public} '/' (l : Card8; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(l));
      return Number(n.Divide(r))
   end '/';

   operator {public} '/' (l : Int64; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(l));
      return Number(n.Divide(r))
   end '/';

   operator {public} '/' (l : Int32; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(l));
      return Number(n.Divide(r))
   end '/';

   operator {public} '/' (l : Int16; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(l));
      return Number(n.Divide(r))
   end '/';

   operator {public} '/' (l : Int8; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(l));
      return Number(n.Divide(r))
   end '/';

   operator {public} '/' (l : string; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(l));
      return Number(n.Divide(r))
   end '/';

   operator {public} '**' (l, r : Number) : Number;
   begin
      return l.Power(r)
   end '**';

   operator {public} '**' (l : Number; r : Real64) : Number;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(r));
      return l.Power(n)
   end '**';

   operator {public} '**' (l : Number; r : Real32) : Number;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(r));
      return l.Power(n)
   end '**';

   operator {public} '**' (l : Number; r : Card64) : Number;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(r));
      return l.Power(n)
   end '**';

   operator {public} '**' (l : Number; r : Card32) : Number;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(r));
      return l.Power(n)
   end '**';

   operator {public} '**' (l : Number; r : Card16) : Number;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(r));
      return l.Power(n)
   end '**';

   operator {public} '**' (l : Number; r : Card8) : Number;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(r));
      return l.Power(n)
   end '**';

   operator {public} '**' (l : Number; r : Int64) : Number;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(r));
      return l.Power(n)
   end '**';

   operator {public} '**' (l : Number; r : Int32) : Number;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(r));
      return l.Power(n)
   end '**';

   operator {public} '**' (l : Number; r : Int16) : Number;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(r));
      return l.Power(n)
   end '**';

   operator {public} '**' (l : Number; r : Int8) : Number;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(r));
      return l.Power(n)
   end '**';

   operator {public} '**' (l : Number; r : string) : Number;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(r));
      return l.Power(n)
   end '**';

   operator {public} '**' (l : Real64; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Real64ToNumberType(l));
      return n.Power(r)
   end '**';

   operator {public} '**' (l : Real32; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Real32ToNumberType(l));
      return n.Power(r)
   end '**';

   operator {public} '**' (l : Card64; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Card64ToNumberType(l));
      return n.Power(r)
   end '**';

   operator {public} '**' (l : Card32; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Card32ToNumberType(l));
      return n.Power(r)
   end '**';

   operator {public} '**' (l : Card16; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Card16ToNumberType(l));
      return n.Power(r)
   end '**';

   operator {public} '**' (l : Card8; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Card8ToNumberType(l));
      return n.Power(r)
   end '**';

   operator {public} '**' (l : Int64; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Int64ToNumberType(l));
      return n.Power(r)
   end '**';

   operator {public} '**' (l : Int32; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Int32ToNumberType(l));
      return n.Power(r)
   end '**';

   operator {public} '**' (l : Int16; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Int16ToNumberType(l));
      return n.Power(r)
   end '**';

   operator {public} '**' (l : Int8; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(Int8ToNumberType(l));
      return n.Power(r)
   end '**';

   operator {public} '**' (l : string; r : Number) : Number;
   var
      n : Number;
   begin
      n.Set(StringToNumberType(l));
      return n.Power(r)
   end '**';

   (* local function *)

   procedure {private} EvalMachineEpsilon () : NumberType;
   var
      epsilon, onePlus : Real64;
   begin
      (* assumes a radix of 2 - the mantissa will be 52 bits +/- a bit *)
      epsilon := one;
      repeat
         epsilon := epsilon / two;
         onePlus := one + epsilon;
      until onePlus.CompareTo(one) = 0;
      epsilon := two * epsilon;
      return epsilon
   end EvalMachineEpsilon;

   procedure {private} SetConstants;
   var
      e, r : Real64;
   begin
      e := EvalMachineEpsilon();
      Epsilon.Set(e);
      r := Real64.MaxValue * e;
      MaximumPositiveNumber.Set(r);
      r := Real64.Epsilon / e;
      MinimumPositiveNumber.Set(r);
      r := Real64.NaN;
      NaN.Set(r);
      r := Real64.NegativeInfinity;
      NegativeInfinity.Set(r);
      r := Real64.PositiveInfinity;
      PositiveInfinity.Set(r)
   end SetConstants;

begin
   zero := Real64.Parse("0.0E+0");
   one  := Real64.Parse("1.0E+0");
   two  := Real64.Parse("2.0E+0");
   SetConstants
end Numbers.